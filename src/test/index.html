<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button id="btn">点击</button>
    <script>
        // 1 函数缓存 外层函数缓存到了变量内
        function add(a) {
            console.log('第一层函数');
            let num = 10
            if (a === 1) {
                return () => {
                    num += a
                    console.log(20, num);
                };
            }
        }
        const tmp = add(1)
        console.log(21, tmp);
        tmp()

        // 2 柯里化 == 闭包 + 递归
        let arr = []
        function addCurry() {
            console.log(34, ...arguments);
            // let arg = Array.prototype.slice.call(arguments); // 递归获取后续参数
            // console.log(36, arg);
            const arg = [...arguments]
            console.log(48, arr);
            arr = arr.concat(arg)
            console.log(38, arr, arg);
            if (arg.length === 0) { // 如果参数为空，则判断递归结束
                console.log(42, arr.reduce((a, b) => { return a + b }));
                return arr.reduce((a, b, c, d) => { console.log(11, a, b, c, d); return a + b }) // 求和
            } else {
                return addCurry;
            }
        }

        // console.log(49, addCurry(1)(2)(3)());

        // 柯里化 运用到防抖
        function debounce(fn, delay) {
            console.log(52);
            delay = delay || 200;
            let timer = null;
            return function () {
                let arg = arguments;
                console.log(57, arg);
                // 每次操作时，清除上次的定时器
                clearTimeout(timer);
                timer = null;
                // 定义新的定时器，一段时间后进行操作
                timer = setTimeout(function () {
                    console.log(63, this);
                    fn.apply(this, arg);
                }, delay);
            }
        };

        var count = 0;
        document.getElementById('btn').addEventListener('click', debounce(function (e) {
            console.log(73, e, ++count); // scroll
        }, 500))

        //高阶函数 节流
        function throttle(fn, delay) {
            delay = delay || 200;
            let timer = null;
            console.log(85, 'first');
            // 每次滚动初始的标识
            let timestamp = 0;
            return function () {
                let arg = arguments;
                let now = Date.now();
                console.log(84, now, timestamp, now - timestamp >= delay);
                // 设置开始时间
                if (timestamp === 0) {
                    timestamp = now;
                }

                clearTimeout(timer);
                timer = null;
                // 已经到了delay的一段时间，进行处理
                if (now - timestamp >= delay) {
                    console.log(95, this, arg);
                    fn.apply(this, arg);
                    timestamp = now;
                }
                // 添加定时器，确保最后一次的操作也能处理
                else {
                    timer = setTimeout(function () {
                        console.log(103);
                        fn.apply(this, arg);
                        // 恢复标识
                        timestamp = 0;
                    }, delay);

                }
            }
        };

        var count = 0;
        // 初始触发第一层函数 将初始层进行闭包缓存，返回
        document.getElementById('btn').addEventListener('click',
            throttle(function (e) {
                console.log(e, ++count); // scroll
            }, 500)
        )

    </script>
</body>

</html>